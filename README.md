**ECS 122A â€“ Algorithm Design & Analysis**

This repository collects my implementations of algorithms from ECS 122A (Algorithm Design & Analysis).
The course focused on the mathematical foundations of algorithms, analyzing their complexity, and applying different design paradigms such as Divide & Conquer, Greedy methods, Dynamic Programming, and Graph Algorithms.

Through these implementations, I strengthened my ability to connect theory with practice â€” proving algorithm correctness, analyzing asymptotic behavior, and coding efficient solutions.

â¸»

ðŸ“š Whatâ€™s Inside

The repository is organized around the major algorithmic paradigms and problem types covered in the course:
	â€¢	Divide & Conquer
Algorithms that recursively split problems into subproblems, including classic sorting and searching approaches.
Learned how recurrence relations and the Master Theorem guide complexity analysis.
	â€¢	Greedy Algorithms
Problems solvable by making locally optimal choices, such as activity selection, Huffman coding, and fractional knapsack.
Learned the importance of proving the greedy-choice property and optimal substructure.
	â€¢	Dynamic Programming (DP)
Step-by-step optimization through overlapping subproblems, including knapsack, rod cutting, LCS, edit distance, coin change, Fibonacci, and even a diamond-shaped DP problem.
Learned to distinguish when DP is better than greedy or divide & conquer, and how to structure recursive definitions.
	â€¢	Graph Algorithms
Core graph search and optimization algorithms: BFS, DFS, shortest paths (Dijkstra, Bellman-Ford, Floyd-Warshall), and spanning trees (Primâ€™s, Kruskalâ€™s).
Learned how to reason about connectivity, cycles, and graph traversal complexity, and how to select the right algorithm for weighted vs. unweighted cases.

â¸»

ðŸš€ Key Takeaways
	â€¢	How to rigorously analyze time and space complexity using Big-O, recurrences, and amortized analysis.
	â€¢	The differences and trade-offs between Divide & Conquer, Greedy, and DP strategies.
	â€¢	How to prove correctness of greedy and DP algorithms.
	â€¢	How classic graph algorithms form the foundation of modern optimization and network problems.
	â€¢	Practical coding experience in translating mathematical ideas into clean, testable implementations.

â¸»

ðŸ’¡ Why This Matters

ECS 122A gave me a deep understanding of algorithmic thinking.
I didnâ€™t just learn to code algorithms â€” I learned why they work, when to use them, and how to argue about their efficiency and correctness.

This repository is both a study record and a toolbox of fundamental algorithms that I can apply to larger software and research projects.

â¸»

ðŸ“– References
	â€¢	Introduction to Algorithms (CLRS)
	â€¢	ECS 122A lecture notes and live exercises
	â€¢	Homework and quiz practice problems
